### 269. Alien Dictionary
#### Problem Statement
[Alien Dictionary](https://leetcode.com/problems/alien-dictionary/)

There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.

You are given a list of strings words from the alien language's dictionary, where the strings in words are sorted lexicographically by the rules of this new language.

Return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language's rules. If there is no solution, return "". If there are multiple solutions, return any of them.

Example 1:
Input: words = ["wrt","wrf","er","ett","rftt"]
Output: "wertf"

Example 2:
Input: words = ["z","x"]
Output: "zx"

Example 3:
Input: words = ["z","x","z"]
Output: ""
Explanation: The order is invalid, so return "".
---

### Main Idea & Intuition

This problem asks us to determine the order of characters in an alien language, given a sorted dictionary of words. The key insight is to model this as a **graph problem**:

1. Each character is a vertex in the graph
2. The relative order between characters creates directed edges
3. The final ordering is a **topological sort** of this graph

To build the graph, we compare adjacent words in the dictionary. When we find the first differing character between two adjacent words, we can infer that the character in the first word comes before the character in the second word in the alien alphabet.

#### Core Concept: Graph Building and Topological Sort

1. **Graph Construction**: Compare adjacent words to determine character ordering
2. **Cycle Detection**: Check if the ordering has contradictions (cycles)
3. **Topological Sort**: Use either BFS (Kahn's algorithm) or DFS to find a valid ordering

### Code Implementation with Detailed Comments

```java
class Solution {
    public String alienOrder(String[] words) {
        // Step 1: Build the graph
        Map<Character, Set<Character>> graph = new HashMap<>();
        Map<Character, Integer> inDegree = new HashMap<>();
        
        // Initialize the graph with all unique characters
        for (String word : words) {
            for (char c : word.toCharArray()) {
                graph.putIfAbsent(c, new HashSet<>());
                inDegree.putIfAbsent(c, 0);
            }
        }
        
        // Build edges by comparing adjacent words
        for (int i = 0; i < words.length - 1; i++) {
            String word1 = words[i];
            String word2 = words[i + 1];
            
            // Check for invalid case: if word1 is a prefix of word2, it should come before
            if (word1.length() > word2.length() && word1.startsWith(word2)) {
                return "";
            }
            
            // Find the first differing character
            int minLength = Math.min(word1.length(), word2.length());
            for (int j = 0; j < minLength; j++) {
                char c1 = word1.charAt(j);
                char c2 = word2.charAt(j);
                
                if (c1 != c2) {
                    // If this ordering hasn't been added yet
                    if (!graph.get(c1).contains(c2)) {
                        graph.get(c1).add(c2);
                        inDegree.put(c2, inDegree.get(c2) + 1);
                    }
                    break; // Only use the first difference
                }
            }
        }
        
        // Step 2: Topological sort using BFS (Kahn's algorithm)
        StringBuilder result = new StringBuilder();
        Queue<Character> queue = new LinkedList<>();
        
        // Add all vertices with 0 in-degree (no dependencies)
        for (char c : inDegree.keySet()) {
            if (inDegree.get(c) == 0) {
                queue.offer(c);
            }
        }
        
        // Process vertices in topological order
        while (!queue.isEmpty()) {
            char current = queue.poll();
            result.append(current);
            
            // Reduce in-degree of neighbors
            for (char neighbor : graph.get(current)) {
                inDegree.put(neighbor, inDegree.get(neighbor) - 1);
                
                // If in-degree becomes 0, add to queue
                if (inDegree.get(neighbor) == 0) {
                    queue.offer(neighbor);
                }
            }
        }
        
        // Check if we have a valid ordering (all characters included)
        return result.length() == inDegree.size() ? result.toString() : "";
    }
}
