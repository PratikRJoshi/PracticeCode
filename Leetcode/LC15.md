### 15. 3Sum
### Problem Link: [3Sum](https://leetcode.com/problems/3sum/)
### Intuition
Sorting the array lets me fix one number and scan the remaining suffix with a bidirectional two-pointer window. Because the numbers are ordered, the sum of the current triple tells me which pointer to move to get closer to zero, while duplicate checks keep the output unique.

### Java Reference Implementation
```java
import java.util.*;

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> results = new ArrayList<>(); // [R0]
        Arrays.sort(nums); // [R1]

        for (int i = 0; i < nums.length - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue; // [R2]
            }

            int left = i + 1;
            int right = nums.length - 1;

            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right]; // [R3]

                if (sum == 0) {
                    results.add(Arrays.asList(nums[i], nums[left], nums[right])); // [R4]
                    left++;
                    right--;

                    while (left < right && nums[left] == nums[left - 1]) {
                        left++; // [R5]
                    }

                    while (left < right && nums[right] == nums[right + 1]) {
                        right--; // [R5]
                    }
                } else if (sum < 0) {
                    left++; // [R6]
                } else {
                    right--; // [R6]
                }
            }
        }

        return results; // [R7]
    }
}
```

### Requirement → Code Mapping
- **R0 (Create container for unique triplets)** `List<List<Integer>> results = new ArrayList<>();`
- **R1 (Order the array to enable two-pointer traversal)** `Arrays.sort(nums);`
- **R2 (Skip duplicate fixed elements)** `if (i > 0 && nums[i] == nums[i - 1]) { continue; }`
- **R3 (Evaluate current triplet sum)** `int sum = nums[i] + nums[left] + nums[right];`
- **R4 (Collect valid triplet when sum hits zero)** `results.add(Arrays.asList(...));`
- **R5 (Advance pointers past duplicates after a match)** inner `while` loops that increment `left`/`right`.
- **R6 (Tighten window based on sum comparison)** pointer adjustments in the `else if` / `else` branches.
- **R7 (Return final list of triplets)** `return results;`

### Relation to 4Sum
- The `threeSum` pattern becomes the inner engine of `fourSum`: fix one extra index (`i`, `j`) and reuse the same two-pointer sweep on the suffix.
- Implementations can literally call a helper mirroring this `threeSum` loop once the first anchor is chosen, demonstrating how `fourSum` is a layered extension of the sorted two-pointer strategy in this file.

### Complexity
- **Time:** `O(n^2)` — sorting is `O(n log n)` and the outer loop with a linear two-pointer scan dominates.
- **Space:** `O(1)` extra beyond the output list because in-place sorting is allowed.