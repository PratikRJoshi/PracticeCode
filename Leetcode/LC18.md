### 18. 4Sum
### Problem Link: [4Sum](https://leetcode.com/problems/4sum/)
### Intuition
Extend the 3Sum two-pointer idea by fixing two numbers instead of one. Sorting the array keeps candidates ordered so the remaining pair can be found with the same inward sweep while pruning duplicates across both fixed indices.

### Java Reference Implementation
```java
import java.util.*;

class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> results = new ArrayList<>(); // [R0]
        Arrays.sort(nums); // [R1]

        for (int i = 0; i < nums.length - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue; // [R2]
            }

            for (int j = i + 1; j < nums.length - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) {
                    continue; // [R3]
                }

                int left = j + 1;
                int right = nums.length - 1;

                while (left < right) {
                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right]; // [R4]

                    if (sum == target) {
                        results.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); // [R5]
                        left++;
                        right--;

                        while (left < right && nums[left] == nums[left - 1]) {
                            left++; // [R6]
                        }

                        while (left < right && nums[right] == nums[right + 1]) {
                            right--; // [R6]
                        }
                    } else if (sum < target) {
                        left++; // [R7]
                    } else {
                        right--; // [R7]
                    }
                }
            }
        }

        return results; // [R8]
    }
}
```

### Requirement → Code Mapping
- **R0 (Create container for unique quadruplets)** `List<List<Integer>> results = new ArrayList<>();`
- **R1 (Sort to enable deterministic scanning)** `Arrays.sort(nums);`
- **R2 (Skip duplicate first anchors)** `if (i > 0 && nums[i] == nums[i - 1])`
- **R3 (Skip duplicate second anchors)** `if (j > i + 1 && nums[j] == nums[j - 1])`
- **R5 (Collect quadruplet matching target)** `results.add(Arrays.asList(...));`
- **R6 (Advance pointers past duplicate inner values)** inner `while` loops after a match.
- **R7 (Shift window pointers based on comparison)** pointer adjustments in the `else if` / `else` branches.
- **R8 (Return results)** `return results;`

### Relation to 3Sum
- The outer loops (`i`, `j`) act as prefix anchors; once they are fixed, the remaining logic is exactly the `threeSum` two-pointer core applied to the rest of the array with a new target (`target - nums[i] - nums[j]`).
- Viewing `fourSum` this way highlights the reusable pattern: sorted order + duplicate pruning + inward pointers, layered one dimension deeper than `threeSum`.

### Complexity
- **Time:** `O(n^3)` — two nested loops plus a linear two-pointer scan on the remainder.
- **Space:** `O(1)` auxiliary beyond the returned list.