### LeetCode 55: Jump Game

## Problem Statement

You are given an integer array `nums`. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.

Return `true` if you can reach the last index, and `false` otherwise.

---

## Intuition and Main Idea

This problem asks whether a destination is reachable, which often suggests graph traversal algorithms like BFS or DFS. However, a much simpler and more efficient **greedy approach** exists.

The core idea is to iterate through the array and keep track of the **farthest index we can possibly reach**. Let's call this `maxReach`.

We start at index 0. The farthest we can reach is `nums[0]`. As we iterate from our current position `i`:

1.  **Check if we are stuck**: If our current index `i` is greater than `maxReach`, it means we've landed on an index that was impossible to get to from any previous position. We are stuck, so we can immediately say it's impossible to reach the end.

2.  **Update our potential**: From our current index `i`, we can jump to any index up to `i + nums[i]`. This might extend our `maxReach`. So, we update `maxReach = max(maxReach, i + nums[i])`.

3.  **Check for success**: If `maxReach` ever becomes greater than or equal to the last index (`nums.length - 1`), we know for sure that the end is reachable, and we can stop and return `true`.

By iterating just once through the array, we can determine if the end is reachable.

---

## Algorithm: Greedy Approach

1.  **Initialization**: Initialize a variable `maxReach = 0`. This will store the farthest index we can reach at any point.

2.  **Iteration**: Loop through the `nums` array with an index `i` from `0` to `nums.length - 1`.

3.  **Inside the Loop**:
    *   **Check if the current index is reachable**: If `i > maxReach`, it means we cannot reach the current index `i`. Return `false`.
    *   **Update the farthest reach**: Calculate the potential new farthest reach from the current position: `i + nums[i]`. Update `maxReach` to be the maximum of itself and this new potential reach: `maxReach = Math.max(maxReach, i + nums[i])`.
    *   **Early Exit (Optional but good practice)**: If `maxReach` is already covering the last index, we can return `true` immediately.

4.  **Conclusion**: If the loop completes without ever getting stuck (i.e., `i > maxReach` was never true), it means every index up to the end was reachable. Return `true`.

---

## Java Implementation

```java
class Solution {
    public boolean canJump(int[] nums) {
        if(nums == null || nums.length == 0){
            return false;
        }

        int farthest = 0;
        // The loop condition `i <= farthest` is the core of this greedy approach.
        // We iterate as long as our current position `i` is within our reach.
        for(int i = 0; i <= farthest && i < nums.length; i++){
            // Update the farthest we can reach from the current position.
            farthest = Math.max(farthest, i + nums[i]);
            
            // If our reach covers the end, we are done.
            if(farthest >= nums.length - 1){
                return true;
            }
        }

        // If the loop completes and we haven't returned true, 
        // it means we got stuck somewhere.
        return farthest >= nums.length - 1;
    }
}
```

---

## Complexity Analysis

Let `n` be the number of elements in the `nums` array.

*   **Time Complexity: O(n)**
    *   We perform a single pass through the array from left to right. The loop runs at most `n` times. Therefore, the time complexity is linear.

*   **Space Complexity: O(1)**
    *   We only use a few variables (`farthest`, `i`, `n`) to keep track of our state. We are not using any auxiliary data structures that scale with the input size. Therefore, the space complexity is constant.
