### LeetCode 3437: Alternating Permutations

## Problem Statement

Given an integer `n`, you need to find all alternating permutations of the first `n` positive integers (1, 2, ..., n).

An alternating permutation is a permutation where no two adjacent elements have the same parity. In other words, odd and even numbers must alternate throughout the entire sequence. For example, `[1, 2, 3, 4]` is an alternating permutation, but `[1, 3, 2, 4]` is not.

The task is to return all valid alternating permutations sorted in lexicographical order.

---

## Intuition and Main Idea

This problem asks us to find all permutations that satisfy a specific constraint (alternating parity). This is a classic signal to use a **backtracking** algorithm. Backtracking is a powerful technique for exploring all possible solutions to a problem by building a solution candidate step-by-step and abandoning a path as soon as it violates any constraints.

### Core Logic: Building the Permutation

The main idea is to construct the permutation one number at a time. At each position, we decide which number to place next based on two rules:
1.  **Uniqueness**: The number must not have been used already in the current permutation.
2.  **Alternating Parity**: The number's parity (odd/even) must be different from the parity of the number at the previous position.

If we successfully place a number, we move to the next position (recurse). If we can't place any valid number, or after we finish exploring a path, we "backtrack" by removing the number we just placed and trying a different one in its place.

### Initial Setup and Constraints

1.  **Separate Odds and Evens**: It's much easier to work with the odd and even numbers if we separate them into two distinct lists first.

2.  **Check Feasibility**: An alternating permutation is only possible if the number of odds and evens are roughly equal. Specifically, the difference between their counts cannot be more than 1. For example, if `n=4`, we have two evens `{2, 4}` and two odds `{1, 3}`. This can work. If `n=5`, we have three odds and two evens. This can also work. But if `n=6` gave us four odds and two evens, it would be impossible. So, if `abs(count_odds - count_evens) > 1`, we can immediately return an empty list.

3.  **Two Starting Scenarios**: A permutation can start with either an odd number or an even number. We will need to run our backtracking process twice to cover both possibilities:
    *   Start with an odd number (if `count_odds >= count_evens`).
    *   Start with an even number (if `count_evens >= count_odds`).

---

## Algorithm: Backtracking

1.  **Preparation**:
    *   Create two lists, `odds` and `evens`, from the numbers 1 to `n`.
    *   Check if `abs(odds.size() - evens.size()) > 1`. If so, return an empty list.
    *   Initialize a list to store the final results: `List<List<Integer>> results`.

2.  **Backtracking Function `generate(currentPermutation, availableOdds, availableEvens, nextIsOdd)`**:
    *   **Base Case**: If `currentPermutation.size() == n`, we have found a complete valid permutation. Add a copy of it to `results` and return.
    *   **Recursive Step**:
        *   If the next number to be placed must be **odd** (`nextIsOdd` is true):
            *   Iterate through each number in `availableOdds`.
            *   For each `oddNum`:
                *   Add `oddNum` to `currentPermutation`.
                *   Remove `oddNum` from `availableOdds`.
                *   Recursively call `generate(..., nextIsOdd = false)`.
                *   **Backtrack**: Remove `oddNum` from `currentPermutation` and add it back to `availableOdds` to restore the state for the next iteration.
        *   If the next number must be **even** (`nextIsOdd` is false):
            *   Do the same as above, but iterating through `availableEvens` and calling `generate(..., nextIsOdd = true)`.

3.  **Initial Calls**:
    *   If `odds.size() >= evens.size()`, start the process by trying to place an odd number first. Call the backtracking function for each initial odd number.
    *   If `evens.size() >= odds.size()`, start the process by trying to place an even number first. Call the backtracking function for each initial even number.

4.  **Sort Results**: The problem requires the results to be in lexicographical order. Since we are building the permutations by picking smaller numbers first from our sorted odd/even lists, the final list of permutations will naturally be generated in lexicographical order. No extra sort is needed.

---

## Java Implementation

```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<List<Integer>> alternatingPermutations(int n) {
        List<List<Integer>> results = new ArrayList<>();
        List<Integer> odds = new ArrayList<>();
        List<Integer> evens = new ArrayList<>();

        // 1. Preparation: Separate numbers into odd and even lists
        for (int i = 1; i <= n; i++) {
            if (i % 2 == 0) {
                evens.add(i);
            } else {
                odds.add(i);
            }
        }

        // Check if a solution is possible
        if (Math.abs(odds.size() - evens.size()) > 1) {
            return results;
        }

        // 2. Start the backtracking process for both scenarios
        // Scenario 1: Start with an odd number
        if (odds.size() >= evens.size()) {
            generate(results, new ArrayList<>(), new ArrayList<>(odds), new ArrayList<>(evens), true, n);
        }
        
        // Scenario 2: Start with an even number
        if (evens.size() >= odds.size()) {
            generate(results, new ArrayList<>(), new ArrayList<>(odds), new ArrayList<>(evens), false, n);
        }

        return results;
    }

    private void generate(List<List<Integer>> results, List<Integer> currentPermutation, List<Integer> availableOdds, List<Integer> availableEvens, boolean nextIsOdd, int n) {
        // Base Case: A full permutation has been formed
        if (currentPermutation.size() == n) {
            results.add(new ArrayList<>(currentPermutation));
            return;
        }

        if (nextIsOdd) {
            // Iterate through available odd numbers to choose the next one
            for (int i = 0; i < availableOdds.size(); i++) {
                int oddNum = availableOdds.get(i);
                
                currentPermutation.add(oddNum);
                availableOdds.remove(i);
                
                // Recurse to find the next number (which must be even)
                generate(results, currentPermutation, availableOdds, availableEvens, false, n);
                
                // Backtrack: undo the choice
                availableOdds.add(i, oddNum); // Restore state
                currentPermutation.remove(currentPermutation.size() - 1);
            }
        } else { // nextIsOdd is false
            // Iterate through available even numbers
            for (int i = 0; i < availableEvens.size(); i++) {
                int evenNum = availableEvens.get(i);

                currentPermutation.add(evenNum);
                availableEvens.remove(i);

                // Recurse to find the next number (which must be odd)
                generate(results, currentPermutation, availableOdds, availableEvens, true, n);

                // Backtrack: undo the choice
                availableEvens.add(i, evenNum); // Restore state
                currentPermutation.remove(currentPermutation.size() - 1);
            }
        }
    }
}
```

---

## Complexity Analysis

Let `O` be the number of odd integers (`ceil(n/2)`) and `E` be the number of even integers (`floor(n/2)`).

*   **Time Complexity: O(O! * E!)**
    *   The number of ways to arrange the odd numbers is `O!`. The number of ways to arrange the even numbers is `E!`.
    *   In our backtracking tree, we are essentially exploring all possible interleavings of these two sets of permutations.
    *   The total number of valid alternating permutations is `O! * E!` (multiplied by 2 if `O == E`). The backtracking algorithm explores exactly this many valid paths to the end.
    *   Therefore, the time complexity is proportional to the number of solutions, which is **O(O! * E!)**.

*   **Space Complexity: O(n)**
    *   **Recursion Depth**: The recursion stack will go at most `n` levels deep, contributing O(n) space.
    *   **Data Structures**: The lists used to store the current permutation, available odds, and available evens will collectively hold `n` elements, also contributing O(n) space.
    *   The space for the `results` list is not typically counted in the space complexity analysis, but if it were, it would be `O(n * (O! * E!))`. The auxiliary space complexity is **O(n)**.

