### 15. 3Sum
### Problem Link: [3Sum](https://leetcode.com/problems/3sum/)
### Intuition
Sorting the array lets me fix one number and scan the remaining suffix with a bidirectional two-pointer window. Because the numbers are ordered, the sum of the current triple tells me which pointer to move to get closer to zero, while duplicate checks keep the output unique.

### Java Reference Implementation
```java
import java.util.*;

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> results = new ArrayList<>(); // [R0] Create container for unique triplets
        Arrays.sort(nums); // [R1] Order the array to enable two-pointer traversal

        for (int i = 0; i < nums.length - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue; // [R2] Skip duplicate fixed elements to avoid duplicate triplets
            }

            int left = i + 1;
            int right = nums.length - 1;

            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right]; // [R3] Evaluate current triplet sum

                if (sum == 0) {
                    results.add(Arrays.asList(nums[i], nums[left], nums[right])); // [R4] Collect valid triplet when sum hits zero
                    left++;
                    right--;

                    while (left < right && nums[left] == nums[left - 1]) {
                        left++; // [R5] Advance left pointer past duplicates after a match
                    }

                    while (left < right && nums[right] == nums[right + 1]) {
                        right--; // [R5] Advance right pointer past duplicates after a match
                    }
                } else if (sum < 0) {
                    left++; // [R6] Increase sum by moving left pointer when sum is too small
                } else {
                    right--; // [R6] Decrease sum by moving right pointer when sum is too large
                }
            }
        }

        return results; // [R7] Return final list of triplets
    }
}
```
### Requirement → Code Mapping
- **R0 (Create container for unique triplets)** `List<List<Integer>> results = new ArrayList<>();`
- **R1 (Order the array to enable two-pointer traversal)** `Arrays.sort(nums);`
- **R2 (Skip duplicate fixed elements)** `if (i > 0 && nums[i] == nums[i - 1]) { continue; }`
- **R3 (Evaluate current triplet sum)** `int sum = nums[i] + nums[left] + nums[right];`
- **R4 (Collect valid triplet when sum hits zero)** `results.add(Arrays.asList(...));`
- **R5 (Advance pointers past duplicates after a match)** inner `while` loops that increment `left`/`right`.
- **R6 (Tighten window based on sum comparison)** pointer adjustments in the `else if` / `else` branches.
- **R7 (Return final list of triplets)** `return results;`

### Relation to 4Sum
- The `threeSum` pattern becomes the inner engine of `fourSum`: fix one extra index (`i`, `j`) and reuse the same two-pointer sweep on the suffix.
- Implementations can literally call a helper mirroring this `threeSum` loop once the first anchor is chosen, demonstrating how `fourSum` is a layered extension of the sorted two-pointer strategy in this file.

### Complexity
- **Time:** `O(n^2)` — sorting is `O(n log n)` and the outer loop with a linear two-pointer scan dominates.
- **Space:** `O(1)` extra beyond the output list because in-place sorting is allowed.